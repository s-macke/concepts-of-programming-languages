Forth - Languages from the Past
Concepts of Programming Languages
29 Nov 2021
Tags: go, programming, logic

Sebastian Macke
Rosenheim Technical University
sebastian.macke@qaware.de
http://www.qaware.de

* Some thoughts about this lecture

- In history there has been developments in language design which had a significant influence
- They had unique ideas from which we can learn from
- These languages are used only a niche language today
- Forth is one of these candidates
- While Forth might be a niche language, its concepts such as a stack machine are not and are widley used
- It is so easy, that we can discuss lexers, parsers and interpreters
- This lecture has two goals. Show a high level language that works totally different and try to write a interpreter

* Forth - Easier than Assembler

https://www.tutorialspoint.com/execute_forth_online.php

* History

- Invented by Charles H. "Chuck" Moore in 1968
- Used in the early microcomputers. Implementations for almost computer types.
- Standardized ANSI Forth in 1994
.link img/01-languages.png
.image img/01-languages.png 300 _

* But not all used equal

.image img/01_redmonk_2021.png 550 _



* Features

- The minimalist language you can imagine
- Stack machine with reverse polish notation
- Procedural language
- control structures, loops, and conditionals
- No types, just integers
- Direct access to call stack
- Most simple lexer of a language you can imagine
- Compiles to threaded code (something in between bytecode and compiled code). Code is very compressed.
- Entire development environment—including compiler, editor, and user programs fits in a few hundred bytes
- Compiled programs usually ship with an embedded interpreter.
- much broader range to define "word" names.
- Forth is a compiled and interpreted language at the same time

* Postfix notation or Reverse Polish Notation
- The order of operations in Forth is Postfix (or Reverse Polish Notation)

* Stack operations
- *dup* - Duplicated the top of the stack
- *swap* - swaps the top 2 elements
- *drop* - drops the top element of the stack
- *rot* - rotate the top 3 numbers

* store and fetch variables

* Functions: Adding a word

* Conditionals

* Control Structures

* If then else

* do loop

* begin until

* strings

* Arrays

* Exercise

- Write a function, which takes one integer as argument and calculates the cube x³ of that number
- Write a loop, which prints the numbers from 1 to 10
- Write a word which applies a rot13 to an integer which represents an ASCII character

    97 emit  ( prints a )
    122 emit ( prints z )
    97 rot13 emit  ( should print n )
    122 rot13 emit ( should print m )

Ignore spaces.

- write a word, which "encrypts" a whole string via rot 13

* Some thoughts

- You can write a forth interpreter in less then 512 bytes

https://www.slideserve.com/holly/the-forth-language

* Stack operations


* Forth Cheat Sheet
    words           lists all word in the dictionary
    .s              show the stack

    +, -, *, /     math operations
    <, >, =        test if the numbers are smaller, larger, equal

    .               pops the top element from the stack and prints its number
    drop            drop a stack item
    dup             duplicate a stack item
    rot             rotate the top 3 elements in the stack

    ( and \         Comments

    : [name] ... ;  Function declaration
    ." ..."         Print the string
    .S" ..."
    type            prints the string on the stack
    cr              prints a new line

    variable [name] defines a int variable
    [variable]      puts the memory position of the variable onto the stack
    @               receives the content from the memory location
    !               stores the content into the memory location


* Forth Examples
https://skilldrick.github.io/easyforth/#conditionals-and-loops
https://www.tutorialspoint.com/execute_forth_online.php


* Building a Forth Interpreter

* Major building blocks

- Stack for integers
- Heap for variables
- Dictionary for words

Words have access to

- The stack
- The list of words executed
- Program counter (can jump to another word)
- Metainformation for each word

* Lexer and Parser and Interpreter

Lexer

- Reads input
- Identifies and Generates a sequence of tokens (Lexing)
- Removes comments

Parser

- Performs syntax analysis
- Performs semantic validation
- Create abstract representation of the code

Interpreter
- Executes the computer program

Forth doesn't fit into the usual text book scheme for building compilers
We have to develop our own way

: https://wiki.c2.com/?ForthVsLisp
: https://www.chegg.com/homework-help/questions-and-answers/3-forth-lisp-abstract-syntax-tree-ast--1--forth-imperative-stack-based-computer-programmin-q64576344

: * Abstract Syntax Tree
: abstract Syntax Tree is a tree representation of the the abstract syntactic structure of source code written in a programming language
: - An AST presentation of Forth is not a good way to represent. Why?

: http://mshang.ca/syntree/
: [* [+ 1 2] 3]
: Warum? Weil die Anzahl der Parameter in Wörtern unbekannt ist. Ist erst zur Ausführzeit bekannt.

* Parser for word pairs
Forth supports several word pairs such as "( ... )", "do ... loop", ": ... ;" and "if ... then"
The parser has to find and check these pairs and provide the meta information for these words.

   2 3 ( this is a comment ) +    <- "(" should point to 7
   0 1 2 3    4  5 6       7

   if do_something then           <- "if" should point to 2
   0  1            2

   do if do_something then loop   <- "do" points to 4, "if" points to "3"
   0  1  2            3    4

   if do do_something then loop   <- Error: if without then, do without loop

Exercise: Try to find an algorithm  (5 minutes)

* Don't cheat

* Don't cheat


* Use Stack itself to determine the control structure offsets


* Shunting Yard algorithm


* Summary

Stackmachines are used throughout
