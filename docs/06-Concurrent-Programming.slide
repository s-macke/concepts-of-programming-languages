Concurrent Programming with Go
Concepts of Programming Languages
2 Nov 2020
Tags: go, programming, concurrent, go routines, channels

Sebastian Macke
Rosenheim Technical University
sebastian.macke@qaware.de
http://www.qaware.de

* Why Concurrent Programming?
- Computer clock rates do not get higher anymore (since 2004!)
- But Moores Law is still valid (Multicore!)
.image img/06-moores-law.png 450 800

* The modern world is parallel

Multicore.

Networks.

Clouds of CPUs.

Loads of users.

* Concurrent Programming with Go
.image img/06-go-concurrency.jpeg
- Don't communicate by sharing memory; share memory by communicating (Rob Pike)

* Go provides:
- concurrent execution (goroutines)
- synchronization and messaging (channels)
- multi-way concurrent control (select)
- low level blocking primitives (locks) - Usually not needed!

* Goroutines

A goroutine is a function running independently  in the same address space as other goroutines

.code snippets/cp /f.runs/

.code snippets/cp /f.starts.running/,/return/

Like launching a function with shell's `&` notation.

* Goroutines are not threads

- (They're a bit like threads, but they're much cheaper)
- Goroutines are multiplexed onto OS threads as required
- When a goroutine blocks the thread will execute other goroutines
- IO Calls and calls calls to the Go Standard Library trigger the scheduler
- There are no thread local variables in Go

* Lecturer 1: A simple example
No Goroutine used yet:

.play ../src/concurrent/channels/lecturer/lecturer1/main.go /lecturer/,/EOF/

What output do you expect?

* Lecturer 2: First Goroutine
Let's call `lecturer()` in a Goroutine:

.play ../src/concurrent/channels/lecturer/lecturer2/main.go /lecturer/,/EOF/

What output do you expect?

* Channels
- Go routines can use channels for safe communication
- Construct a channel

    c := make(chan int)     // buffer size = 0
    c := make(chan int, 10) // buffer size = 10

- Send to channel

    c <- 1

- Read from channel

    x = <- c

- size = 0 (=default): Sender blocks until a reader requests a value from the channel
- size = n: Sender is not blocked until the buffer size is reached

* Channels

Channels are typed values that allow goroutines to synchronize and exchange information.

.code snippets/cp /make.*chan/,/completedAt/

* Channel and Errors
- Channel can be closed. Readers will return immediately. Successive writes will cause panic.

    close(c)

- If a channel was closed, the reader gets "false" as return code (second return value)

    value, ok := <-c

- Reading from a channel until closed

    for {
        x, ok := <-c
        if !ok {
            break
        }
        // do something with x
    }
    // channel closed

* Channels: Deadlocks
The following code might look good at first sight, but causes a deadlock:

.play ../src/concurrent/channels/deadlock/main.go

Expected output?

* Lecturer 3: Channels
Let's use channels for communication:

.play ../src/concurrent/channels/lecturer/lecturer3/main.go /lecturer/,/EOF/

* Lecturer 4: Channels
We can also return an (outgoing) channel instead of passing it as parameter:

.play ../src/concurrent/channels/lecturer/lecturer4/main.go /lecturer/,/EOF/


* Exercise 1: Generator
Write a generator for Fibonacci numbers, i.e. a function that returns a channel where the next Fibonacci number can be read.

.play ../src/concurrent/channels/fibonacci/main.go /MAIN/,/EOF/

Also write a test for the `fib()` function.

* Lecturer 5: Anne & Bart
We're adding another (slower) lecturer to make it more interesting:

.play ../src/concurrent/channels/lecturer/lecturer5/main.go /lecturer/,/EOF/

#* Ping Pong
#.play ../src/concurrent/channels/pingpong/pingpong.go /Ball/,/EOF/

* Lecturer 6: Fan In
.play ../src/concurrent/channels/lecturer/lecturer6/main.go /START/,/EOF/

* Lecturer 7: Select
.play ../src/concurrent/channels/lecturer/lecturer7/main.go /lecturer/,/EOF/

* Select
The `select` statement is like a `switch`, but the decision is based on ability to communicate rather than equal values.

.code snippets/cp /select/,/}/

Without default case, the select blocks until a message is received on one of the channels.

* Exercise 2: Timeout
Write a function `setTimeout()` that times out an operation after a given amount of time. Hint: Have a look at the built-in `time.After()` function and make use of the `select` statement.

.play ../src/concurrent/channels/timeout/main.go /MAIN/,/EOF/

Also write a test for the `setTimeout()` function.

* Fan In
- Merge n channels into one
.code ../src/concurrent/channels/fan/fanin.go /FanIn/,/FanIn OMIT/

: einf채chern, zusammenf체hren

* Fan Out
- Read tasks from a channel and start parallel processing. Results will be written in a result channel.
.code ../src/concurrent/channels/fan/fanout.go /FanOut/,/EOF OMIT/

: auff채chern

* Go really supports concurrency

Really.

It's routine to create thousands of goroutines in one program.
(not unusual to debug a program after it had created even millions goroutines)

Stacks start small, but grow and shrink as required.

Goroutines aren't free, but they're very cheap.

More information about Go and concurrency:

.link https://youtu.be/f6kdp27TYZs?t=1


* Java like BlockingQueue with Channels
.code ../src/concurrent/channels/blockingqueue/blockingqueue.go /BlockingQueue/,/EOF/

* Java like BlockingQueue - Test
.code ../src/concurrent/channels/blockingqueue/blockingqueue_test.go /TestBlockingQueue/,/EOF OMIT/

* Java like BlockingQueue with Locks (Low Level)
.code ../src/concurrent/locks/blockingqueue/blockingqueue.go /BlockingQueue/,/A1/

* Java like BlockingQueue with Locks (Low Level)
.code ../src/concurrent/locks/blockingqueue/blockingqueue.go /Put/,/A2/


* Exercise 3: Dining Philosophers

.image img/06-dining-philosophers.png 500 600


* Dining Philosophers with Channels

.image img/06-philosophers-channel.jpeg 600 800

: TODO, ohne Erkl채rung sinnlos.

* Dining Philosophers - Hints
- The table itself should be a Go Routine and should handle all forks in a single thread. This makes synchronization easy.
- The philosopher itself should be kept simple. It uses mainly the API of the table
- Never grab one fork and wait for the other. This is a deadlock situation.
- If you can't get the second fork, you should immediately release the first one.
- The philosopher loop looks like this:

    // Main loop
    func (p *Philosopher) run() {
        for {
            p.takeForks()
            p.eat()
            p.putForks()
            p.think()
        }
    }

* Wrong Solutions
- There are many wrong solution on the web.
- Most of them share the problem that the Philosopher picks up the left fork (implemented with channels or locks) and immediately the right fork.
- The problem arises, when the second fork is in use. There is a potential deadlock, when all Philosophers wait on the second fork.
- In theory a deadlock occurs if there is a cycle in the Resource Allocation Graph.

.link https://play.golang.org/p/rXCotNNY24

* Summary
- With Go you can solve sync problems with channels 
- Channels use Message Passing instead of locks
- Go has a low level lock API, but this is seldom needed
- It is possible to port all classes from java.util.locking easily

: TODO Parallel For Loop, Performance