Functional Programming
Concepts of Programming Languages
25 Oct 2022
Tags: go, programming, master

Sebastian Macke
Rosenheim Technical University
Sebastian.Macke@th-rosenheim.de
https://www.qaware.de

* Last lecture
- Functional programming in general
- Impure Functional programming in Go
- Anonymous functions
- Closures
- Currying
- Functional composition
- Lambda Calculus
- Streaming functionality in Go

* Recap: Pure Functions

* What is a pure function?

- Its return value always the same for the same arguments
- The evaluation has no side effects (no mutation of data outside of the function)
- In other words: After calling a pure function, the rest of the program will be in the same state it was before calling

Examples: exp, sin, cos, max, min.

Advantages

- Reading and understanding is simpler
- Easier to test
- Are less prone to error in general

* Recap: Functional Programming – Characteristics

The most prominent characteristics of functional programming are as follows

- Functional programming languages are designed on the concept of mathematical functions that use conditional expressions and recursion to perform computation.
- Functional programming supports higher-order functions and lazy evaluation features.
- Functional programming languages don’t support flow Controls like loop statements and conditional statements like If-Else and Switch Statements. They directly use the functions and functional calls.
  Hence, the declarative approach is prevalence rather than the imperative approach.
- Like OOP, functional programming languages can support popular concepts such as Abstraction, Encapsulation, Inheritance, and Polymorphism

* Recap: Functional programming offers the following advantages

- Bugs-Free Code

Functional programming does not support state, so there are no side-effect results and we can write error-free codes.

- Efficiency

Functional programs consist of independent units that can *run* *concurrently*. As a result, such programs can be more efficient.

- Lazy Evaluation

Functional programming supports *lazy* *evaluation* like Lazy Lists, Lazy Maps, etc.

- Distribution
Functional programming supports distributed computing

: Bug-free: Formal verification is also much easier

* Haskell

- Haskell was developed by a team led by Professor John Hughes at the University of Glasgow in 1990.
- Haskell is a general-purpose, statically-typed, purely functional programming language with type inference and lazy evaluation
- Designed for teaching, research and industrial applications
- Haskell has pioneered a number of programming language features such as type classes, which enable type-safe operator overloading, and monadic IO
- 28th most popular programming language by Google searches for tutorials

* Websites to experiment with Hakell

.link https://replit.com/languages/haskell
.link https://www.jdoodle.com/execute-haskell-online/
.link https://www.onlinegdb.com/online_haskell_compiler

Online tutorials
.link http://learnyouahaskell.com/chapters
.link http://learn.hfm.io/


* Haskell I: Hello world

  main = print "Hello, World!"

1. Define a function with name "main" with no input and output parameters.
Execute the function print, which takes one arbitrary argument. In this case a string

- Printing text doesn't seem to have any side effects

Online editor:
.link https://replit.com/languages/haskell

* Haskell: Type System

- Supports typical basic types such as Int, Float, Double, Char, String, Bool, etc.

  2 + 15 => 17
  40 * 100 => 4900
  5 == 5 => True
  5 == 5.0 => True
  True && False => False
  not False => True
  "Hello" ++ " World" => "Hello World"
  [1,2,3] ++ [4,5,6] => [1,2,3,4,5,6]
  [1,2,3] !! 1 => 2

: - Supports user-defined types such as data types, type synonyms, and newtypes
: - Supports type classes
: - Supports type inference

* Haskell: Variables

- Variables are immutable
- Variables are defined using the let keyword

  r = 5 -- actually a function, which always returns 5
  main = do
         let n = r
         print n
         let m = n + 1
         print m

* Haskell: Functions

  inc x = x + 1
  main = print (inc 1)

- alternative syntax

  inc x = x + 1
  main = print $ inc 1

* Haskell: Partial Applications

  add a b = a + b
  main = print $ add 1 2

- alternative syntax

  add a b = a + b
  main = do
         let c = add 1 -- partial application
         print $ c 2

- So this makes sense

  add a b = a + b
  main = print( (add 1) 2)

* Haskell: Type signatures

    add :: Int -> Int -> Int
    add a b = a + b
    main = print $ add 1 2

- Function signatures are optional, but they provide documentation for other programmers and help the Haskell system to spot type errors

* Haskell: Prefix and Infix Notation

-- add with prefix notation
main = print (+) 1 2

- Infix notation

  add a b = a + b
  main = print $ 1 `add` 2

- Infix notation with brackets

  add :: Int -> Int -> Int
  add a b = a + b
  main = print $ (1 `add` 2)

* Haskell: Overloading

TODO

* Haskell: Control Flow

 - with if-then-else

 max a b = if a > b then a else b
 main = print $ max 1 2

 - with guards

    max :: Ord a => a -> a -> a  (TODO)
    max a b | a > b = a
            | otherwise = b
    main = print $ Main.max 1 2 -- max already exists, so be more specific

* Haskell: Recursions

- Using recursion (with the "ifthenelse" expression)
  factorial n = if n < 2
                then 1
                else n * factorial (n - 1)
  main = print (factorial 10)

-- Using recursion (with pattern matching)
  factorial 0 = 1
  factorial n = n * factorial (n - 1)
  main = print (factorial 10)

-- Using a list and the "product" function
  factorial n = product [1..n]


* Haskell: Local bindings

- Using "where"
use diamater and radius

TODO


* Haskell: Tuples

- How to return multiple values from a function?

  add a b = (a + b, a - b)
  main = print $ add 1 2

- How to access the elements of a tuple?

      add a b = (a + b, a - b)
      main = do
            let (x, y) = add 1 2
            print x
            print y

- can be used also as key-value pair or as a list or as 2D-coordinates
TODO

* Haskell: Lists
TODO



: * Haskell II: Fibonacci
:   fib :: Int -> Int
:   fib 0 = 0
:   fib 1 = 1
:   fib n = fib (n-1) + fib (n-2)
:   main = print (fib 10)

:  1. Define a function fib with takes an argument of type int and returns an int
: 2. Define the function fib which takes as input the number 0 and return 0
: 3. Else: Define the function fib which takes as input the number 1 and return 1
: 4. Else: Define the function fib for an arbitrary integer n and execute the function itself with the arguments n-1 and n-2 and add the result
: 5. Execute the function fib with the number 10 and print the result
: The order of line 2, 3, 4 matters

* Haskell: Functional Composition

  import Data.List
  revsort = (reverse . sort)
  main = print $ revsort [2,8,7,10,1,9,5,3,4,6]

2. Sort takes a list and returns a sorted list. The result of sort is pipelined to reverse
3. prints the result of revsort for the given table

* Haskell V: Lazy evaluation

  osc :: [Integer]
  osc = 0 : 1 : osc
  main = print (osc!!10)

1. Define a function osc, which returns a list of integers of unknown size
2. Define a function osc, which returns oscillating numbers 0,1,0,1,0,1. There is no break condition in this list!
3. Execute the function fibs which actually should return an infinite list. But is not evaluated yet.
   Take the 10th element out of the list. Print the result

The order of the function evaluation is O(N) or even O(N²), instead of O(1)

* Haskell IV: Communication with the outside world

Also Haskell have to perform IO

  import Data.Time.Clock
  import Control.Concurrent

  main = do {
    x <- getCurrentTime;
    print x;
    threadDelay 1000000;
    x <- getCurrentTime;
    print x
  }

The <- sign executes a non-pure function

* Haskell: Higher Order Functions

TODO
