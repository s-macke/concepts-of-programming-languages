Go Programming - OOP
Concepts of Programming Languages
18 Oct 2021
Tags: go, programming, master

Sebastian Macke
Rosenheim Technical University
sebastian.macke@qaware.de
http://www.qaware.de

* Last lecture
- Types (string, int, bool, float64, ...)
- Functions and Control Structures
- Unit Tests
- Arrays, Slices and Maps
- Comparison
- Pointer
- Type Conversion and Downcast
- Flag API, File API

: Ergebnisse der Übungen zeigen.

* Exception Pro and Cons

Pro Exceptions:

- Separate error handling code from the normal program flow
- Exceptions are harder to ignore
- Exceptions can carry a lot of extra information
- Exceptions are easily propagated through the system

Contra Exceptions:

- Difficult to analyze if stack unwinding lead to further errors. E. g. Exceptions in Exceptions. Unexpected resource leaks
- Exceptions can have more side effects
- Exceptions are expensive

* Return values Pro and Cons

Pro error return code:

- Easier to understand
- Multiple return values are a good fit. It does not overload the return value
- Better controllable than Exceptions.

Contra error return code:

- Handling errors is verbose and repetitive (4x more Code in average)
- you have to propagate the error through your call stack yourself

: Hier die Begrüundung von Google: https://golang.org/doc/faq#exceptions


* Errors in Go

Go distinguishes between recoverable and unrecoverable errors

recoverable e. g. file not found

- Go returns the error as one of return values

	err := ioutil.WriteFile(src.Name(), []byte("hello"), 0644)
	if err != nil {
		log.Error(err)
	}

unrecoverable: array access outside its boundaries, out of memory

* TODO: defer als Alternative zu finally

* panic and recover
.play ../src/basics/panic/panic.go  /func getElement/,/EOF OMIT/

* Go does support a dynamic type

.play ../src/basics/dynamic/main.go /START OMIT/,/END OMIT/

- interface{} act a little like "Object" in Java or "void" in C

* The Downcast Syntax is similar to a Function Call
.code ../src/oop/stack/stack_test.go /TestCasting/,/END OMIT/
- Object types (e.g., Containers) are used by pointers (no copies)
- Data types (e.g., Money, Date, ...) are used by value (copies)
- The downcast is safe (== dynamic_cast in C ++ or cast in Java)
- No dereference (*s) is needed to call a method


* Generics

- Go is either type safe + use-case specific or type-unsafe + use-case agnostic.
- This changes with Go 1.18

    type comparable interface {
        type int, int8, int16, int32, int64,
        uint, uint8, uint16, uint32, uint64,
        float32, float64
    }

    func max[T comparable](x T, y T) T {
        if (x > y) {
            return x;
        }
        return y;
    }

: https://stackoverflow.com/questions/62147158/operator-not-defined-for-t
: https://go2goplay.golang.org/p/XF6wM3JF2QM
: https://www.linkedin.com/pulse/functional-programming-go-118-generics-ani-channarasappa

: "ToString" - The Stringer Interface
: .code ../src/oop/rational/rational.go /Stringer/,/Stringer OMIT/
:    r1 := NewRational(1, 2)
:    fmt.Println(r1) // -> (1/2)
: - Works for any type
:    type number int64
:    func (n Number) String() string {
:      return fmt.Sprintf(% x, n)
:    }

: * The Base Type for Container is the Empty Interface (interface{})
: .code ../src/oop/stack/stack.go /Stack/,/END OMIT/

* Structure of object oriented programming

classes: Data and procedures which acts on the data. Blueprint for objects

Attributes: State of the object

Methods:

objects: instances of classes

* Principles of Object Oriented Programming

- Encapsulation: Bundling of data with the methods that operate on that data
- Inheritance: Based class upon another class
- Polymorphism: function overloading, overriding, and virtual functions
- Abstraction: Provide abstraction of a class without the implementation

Go is not a pure object oriented programming language but
allows an object-oriented style of programming

: No inheritance in Go, but embedding

* Object Oriented Programming
- Classes: data and procedures
- Objects: instances of classes
- Class-based vs. Prototype-based
- Encapsulation
- Polymorphism
- Composition, inheritance, and delegation
- Delegation vs. Consultation or Forwarding

: Class-based: Classes first, e.g. Java. Objects are instantiated based on classes
: Prototype-based: Objects first, e.g. Javascript. Classes do not exist, but exactly one link to a prototype exists
: Encapsulation: via upper-/lowercase in Go
: Polymorphism: implicit in Go
: Composition: Objects can contain other objects in their instance variables
: Inheritance: not supported in Go
: Delegation: evaluating a member of one object (the receiver) in the context of another original object (the sender)

: https://flaviocopes.com/golang-is-go-object-oriented/
: https://code.egym.de/introduction-to-oop-in-golang-e4841a9c4e3e

* Encapsulation

- mechanism that binds together code and the data it manipulates

.code ../src/oop/rational/rational.go /Rational/,/END1 OMIT/
.code ../src/oop/rational/rational.go /Multiply/,/Multiply OMIT/
.code ../src/oop/rational/rational.go /NewRational/,/END2 OMIT/

* The typical OO Syntax (object.method()) is supported in Go
.code ../src/oop/rational/rational_test.go /TestRational/,/END OMIT/

:Object Oriented Programming - Custom Types
:Go has no classes but types and functions

* Embedding
- Go does not support inheritance: Go supports embedding of other structs.
.code ../src/oop/polymorphism/polymorphism.go /Point/,8

.code ../src/oop/polymorphism/polymorphism.go /ColorPoint/,19

.code ../src/oop/polymorphism/polymorphism.go /cp.x/,35

- In Java this can be done with delegation.
- Syntactically it is similar to inheritance in Java
- Access to embedded field is identical to a normal field inside a struct
- Overriding of methods is supported, overloading is not!
: Overloading is generally not possible in Go

* Polymorphism
.code ../src/oop/polymorphism/polymorphism.go /ColorPoint/,/END1 OMIT/

    type Stringer interface {
        String() string
    }

- Interfaces are implemented implicitly
- Go supports polymorphism only via interfaces, not through classes

* Interfaces and Polymorphism
.play ../src/oop/polymorphism/polymorphism.go /func main/,/END2 OMIT/

* Send Mail with Go: A minimal Interface
.code ../src/oop/mail/mail.go /Message/,/END OMIT/
- A example interface for a service-oriented component

* A type implements an interface when providing the required methods
.code ../src/oop/mail/smtp/sender.go /Package/,/END OMIT/
- Import references fully qualified VC directories in $GOPATH/src

* The Go interface can be used as in Java
.code ../src/oop/mail/client/client.go /Package/,/EOF OMIT/

* Delegation vs. Consultation or Forwarding
.play ../src/oop/delegation/delegation.go /A/,/EOF OMIT/
: prints "a.bar"
: real delegation should print "b.bar", because delegation means
: evaluating the receiver member method Foo() of A in the context of the sender object B

* Summary
- Several interfaces can be put together to form an interface
- Go does not support inheritance but type embedding (delegation without syntactic ballast)
- Go supports polymorphism only via interfaces, not through classes
- Interfaces with one method end with the ending "er" (Stringer, Writer, Reader...)

* Video
.link https://youtu.be/Ng8m5VXsn8Q?t=414
: Start at 6:54 (Object orientation in Go)
: Stop at 32:06 (Concurrency)

* Embedding
.code ../src/oop/embedding/embedding.go /Introducer/,/EOE OMIT/

* Embedding (cont.)
.code ../src/oop/embedding/embedding.go /Employee/,/EOF OMIT/

* Takeaways
- Implicit polymorphism means fewer dependencies and no type hierarchy
- Inheritance can cause weak encapsulation, tight coupling and surprising bugs
- Struct embedding is still composition, but makes life easier
- Interface embedding makes mocking easy

* Exercise 3
.image img/03-exercise.png 600 800

* Exercise 
- Implement the UML diagram with Go
- The Paint() method should print the names and values of the fields to the console
- Allocate an array of polymorph objects and call Paint() in a loop 
.link https://github.com/s-macke/concepts-of-programming-languages/blob/master/docs/exercises/Exercise3.md

* Questions
- What is the difference between inheritance in Java and embedding in Go?
- How does Go support multiple inheritance? Is is supported for interfaces and types?

* Multiple inheritance
.code ../src/oop/multi/multi.go /Fooer/,/END1 OMIT/

* Multiple inheritance (cont.)
.play ../src/oop/multi/multi.go /END1 OMIT/,/EOF OMIT/
