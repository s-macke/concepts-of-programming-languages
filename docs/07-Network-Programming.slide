Network Programming
Concepts of Programming Languages
15 Nov 2021
Tags: go, programming, concurrent, go routines, channels

Sebastian Macke
Rosenheim Technical University
sebastian.macke@qaware.de
http://www.qaware.de

* About this Lecture

- Go is developed for the cloud and for micro services as light weight alternative to Java and C++
- Hence we should take a look into the capabilities of Go in comparison with Java.
- Virtual Threads with non-blocking behavior should be ideal for receiving requests and waiting for database etc. We have to Benchmark to see the outcome.
- So far in all major languages, networking is not part of the language itself but provided via librarys.

* Distributed Programming
- Concurrent System - multiple execution points (threads, processes or via network)
- Distributed System - processes are running on different networked processors
- Parallel System - like a distributed system, but more closely coupled (shared memory or fast bus)

Terms are not always used consistently.

: Nebenl채ufiges System: es gibt mehrere separate Ausf체hrungspunkte (egal ob Threads/Prozess oder 체ber Netzwerk)
: Verteiltes System: Prozesse laufen auf unterschiedlichen Prozessoren, die oft weit auseinderliegen, aber verbunden sind
: Paralleles System: wie verteiltes System, aber enger gekoppelt (gemeinsamer Speicher, schneller Bus)

*
.background ./img/07-parallel-distributed.png 600 _

* Message Passing
Message Passing is invoking behavior on a separate process (not necessarily on the same computer) by sending messages.

Models for exchanging messages:

- point to point (symmetric/asymmetric, synchronous/asynchronous)
- remote procedure calls (RPC, RMI)
- broadcasting and multicasting

: Sender schickt Nachricht an Empf채nger
: symmetrisch: beide kennen sich / asymmetrisch: nur ein eine Richtung
: synchron: blockiert bis Nachricht gelesen
: RPI: wie lokaler Prozeduraufruf

* TCP - Transmission Control Protocol

- TCP is currently the basis for almost all network communication
- Allows consistent data streams in both direction between two computers

* Networking was heavy weighted in the past

   int main()
   {
       int sockfd, connfd, len;
       struct sockaddr_in servaddr, cli;
       sockfd = socket(AF_INET, SOCK_STREAM, 0);
       if (sockfd == -1) {
           printf("socket creation failed...\n"); exit(0);
       }
       bzero(&servaddr, sizeof(servaddr));
       servaddr.sin_family = AF_INET;
       servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
       servaddr.sin_port = htons(PORT);

       if ((bind(sockfd, (SA*)&servaddr, sizeof(servaddr))) != 0) {
           printf("socket bind failed...\n"); exit(0);
       }
       if ((listen(sockfd, 5)) != 0) {
           printf("Listen failed...\n"); exit(0);
       }
   ....

* Listen to a socket in Go

	l, err := net.Listen("tcp4", ":8080")
	if err != nil {
		fmt.Println(err)
		return
	}

* HTTP Request via TCP

.code ../src/servers/tcp/http/http.go /func/,


* Exercise: Warm up

Make a TCP connection with *towel.blinkenlights.nl* on port *23* and, read from the data stream and write the output onto the screen in an infinite loop.

* Port Scanner

.code ../src/servers/tcp/portscanner/main.go /func/,

* Remote Procedure Call

* Remote Procedure Call

- RPC is a mechanism for calling remote procedures on a remote machine


- The client sends a request to the server

- Go offers a simple way to implement RPC via the net/rpc package


* RPC - Remote procedure call in Go
The server

.code ../src/distributed/rpc/multiply/server.go /type/,

* RPC - Remote procedure call in Go
The client

.code ../src/distributed/rpc/multiply/client.go /type/,

* Exercise: Remote Procedure Call

Implement in Go a net/rpc client TCP connection via rpc.Dial against the URL *simulationcorner.net:1234* . This interface offers two remote procedures calls.

A function, in which you receive a rune

    var dummy struct {}
    var output rune
    err := client.Call("Session.Read", &dummy, &output)

and a function in which you have to provide a rune

    var input rune
    err := client.Call("Session.Write", &input, &dummy)

Create for each routine its own goroutine and call these functions in an infinite loop. Write the output of *Session.Read* to the terminal. As input for *Session.Write* use os.Stdin to read a rune from keyboard via

    reader := bufio.NewReader(os.Stdin)
    input, _, err := reader.ReadRune()

* Service-oriented Request-Response communication with gRPC

- Developed by Google in 2015
- HTTP/2 transport protocol
- Protocol buffers for serialization
- Communication ways
Request-Response
Client-side Streaming
Server-side Streaming
Bidirectional Streaming

- Generator for client and server
Available for C++, C#, Dart, Go, Java, kotlin, Node-Js, Objective-C, PHP, Python, Ruby


* HTTP

* A simple fileserver
.code ../src/servers/fileserver/main.go /func/,
- File server for static content.
- Already optimized for maximum performance. No tweaking in any form necessary.

: TODO every handler is its own virtual thread

* Transfer formats

* There are different types of standardized transfer formats

- JSON (Text Format)
- XML (Text Format)
- Protobuf (Binary Format)

* JSON - JavaScript Object Notation

  {
      "coord": {
          "lon": -122.08,
          "lat": 37.39
        },
        "weather": [
            {
                "main": "Clear",
                "description": "clear sky",
            }
        ],
  }

Types:
- bool
- floating point number
- strings
- arrays
- null

* XML

TODO

* Protocol Buffers

  syntax = "proto3"
  message SearchRequest {
      string query = 1
      int32 page_number = 2
      int32 result_per_page = 3
  }

- published by Google in 2008
- language neutral
- platform independent
- binary format
- Auto generated code by a protobuf compiler for the various languages

* Marshalling and Unmarshalling
- Go offers a way to transform structs to the transfer formats and vice versa
.play ../src/distributed/encoding/json/json.go /type Weather/,

* XML

- Go offers a way to transform structs to the transfer formats and vice versa
.play ../src/distributed/encoding/xml/xml.go /type Weather/,



* Service-oriented Request-Response Communication with REST

* REST APIs with Go

* Example: Weather API with Go

.play ../src/distributed/rest/client.go /func main/,

* Exercise

Call the Github API with Go to receive the repositories with the most stars and the query "awesome"

.link https://api.github.com/search/repositories?sort=stars&order=desc&q=awesome

- Use
.link https://mholt.github.io/json-to-go/
to instantly create a Go structure from an arbitrary JSON.

What are the names of the repositories?

* Comparison with Java I
.code ../src/servers/benchmark/javasimple/Server.java /public class/,

* Comparison with Java (Spring Boot)

    @SpringBootApplication
    @RestController
    public class RestdemoApplication {
        public static void main(String[] args) {
            SpringApplication.run(RestdemoApplication.class, args);
        }

        @GetMapping("/")
        public String index() {
            return "Greetings from Spring Boot!";
        }
    }

- Frameworks such as Spring Boot offer a declarative approach via annotations

* Demo: Benchmark Go vs. Java

* Project Loom
.link https://openjdk.java.net/projects/loom/
- Project to implement lightweight user-mode threads (fibers) into Java



: Alternative http https://api.github.com/users/s-macke/repos

* Exercise

Write a microservice, which exposes
b) A rest api call

a) An embedded file system with an index.html file



* Summary
- Go is an excellent choice for distributed applications
- You can implement the Raft specification with ca 1000-2000 Loc
- You can learn from the Etcd implementation, which is on Github
- Building a production safe implementation is hard in any language anyway!

: TODO: Exersice: Distributed calculation of the Collatz Conjecture
: TODO Use TCP Stream, HTTP with JSON, HTTP with XML, GRPC
: https://www.youtube.com/watch?v=094y1Z2wpJg
: Extends to blocks to optimize
