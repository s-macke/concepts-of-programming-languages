Functional Programming with Go
Concepts of Programming Languages
26 Oct 2020
Tags: go, programming, master

Sebastian Macke
Rosenheim Technical University
sebastian.macke@qaware.de
http://www.qaware.de

: https://www.digicomp.ch/blog/2015/10/20/einfuehrung-in-die-funktionale-programmierung

* What is functional programming?
- Functional programming is a programming paradigm within functions can not only be defined and applied, but also how data can be linked together, used as parameters, and occur as function results. This allows a functional program to compose and apply new calculation rules at runtime in a very wide range.
- Hence, functions are treated as first-class citizens.

* Function as variable
- Similar to a normal function, but the function is not global accessible.

    func main() {
        ADD := func(x,y int) int {
           return x + y;
       }
       fmt.Println(ADD(1, 2)); // -> returns 3
    }

- Anonymous functions variable can be copied.

    MYADD := ADD;
    MYADD(1, 2);

- The function doesn't need to be bound to a variable

    func main() {
       fmt.Println(func(x, y int) int { return x + y; }(3, 4)); // -> returns 7
    }

* Function as parameter.

    func main() {
    	data := []int{27, 15, 8, 9, 12, 4, 17, 19, 21, 23, 25}
    	sort.SliceStable(data, func(i, j int) bool {
    		return data[i] < data[j]
    	})
    	fmt.Println(data)
    }

- Perform a function x times

    func do(f func(int), loops int) {
        for i := 0; i < loops; i++ {
            f(i);
        }
    }

    func main() {
        printvalue := func(i int) { fmt.Println(i) }
        do(printvalue , 5)
    }

: Frage: Welche Algorithmen kennt ihr noch, in denen eine Funktion eingebettet werden kann. Sortierung, Suche, ForEach, Streams Filter, Web-API Aufrufe, Threads

* Function as return value.

    type areaFunc func(int, int) int
    func getAreaFunc() areaFunc {
        return func(x, y int) int {
            return x * y
        }
    }

    func main() {
        areaF := getAreaFunc()
        res := areaF(2, 4)
        fmt.Println(res)
    }

: Clojure/Funktionsabschluss: Eine anonyme Funktion, die Zugriffe auf ihren Erstellungskontext enthält. Beim Aufruf greift die Funktion dann auf diesen Erstellungskontext zu. Dieser Kontext (Speicherbereich, Zustand) ist außerhalb der Funktion nicht referenzierbar, d. h. nicht sichtbar.
: Go erlaubt aber auch globale variablen in anonymen Funktionen. Diese sind also einsehbar.

* Clojures (Only impure if you modify the closed-over variable)
.play ../src/functional/clojures/main.go /intSeq/,/EOF OMIT/

* Exercise 5.1 - Warm Up
Write a Go Programm which shows the following concepts:

- Functions as Variables
- Anonymous Lambda Functions
- High Order Functions (functions as parameters or return values)
- Clojures (https://en.wikipedia.org/wiki/Closure_(computer_programming))

* What is Functional Programming?
- What is a pure function?
  Its return value always the same for the same arguments
  The evaluation has no side effects (no mutation of data outside of the function)
  Hence cannot have any side-effects
  After calling a pure function, the rest of the program will be in the same state it was before calling

  Examples: exp, sin, cos, max, min.
  - The Clojure from the previous slide is not pure.

  - advamtages
    - Reading and understanding is much simpler
    - Easier to test
    - Are less prone to error in general
    - The prevalence of declarative approach rather than imperative approach.

* What is pure Functional Programming?
.image ./img/04-lambda.png 200 350
- The combination of pure functions

: TODO: https://en.wikipedia.org/wiki/Purely_functional_programming
: https://dev.to/tamerlang/the-simple-guide-to-programming-paradigms-36o#structured-programming

* Functional Programming – Characteristics

The most prominent characteristics of functional programming are as follows

- Functional programming languages are designed on the concept of mathematical functions that use conditional expressions and recursion to perform computation.
- Functional programming supports higher-order functions and lazy evaluation features.
- Functional programming languages don’t support flow Controls like loop statements and conditional statements like If-Else and Switch Statements. They directly use the functions and functional calls.
- Like OOP, functional programming languages support popular concepts such as Abstraction, Encapsulation, Inheritance, and Polymorphism

* Functional programming languages are categorized into two groups
- *Pure* Functional Languages
These types of functional languages support only the functional paradigms and have no state. For example − Haskell.

- *Impure* Functional Languages
These types of functional languages support the functional paradigms and imperative style programming. For example − LISP.

* Functional programming offers the following advantages

- Bugs-Free Code

Functional programming does not support state, so there are no side-effect results and we can write error-free codes.

- Efficiency

Functional programs consist of independent units that can *run* *concurrently*. As a result, such programs are more efficient.

- Lazy Evaluation 

Functional programming supports *lazy* *evaluation* like Lazy Lists, Lazy Maps, etc.

- Distribution 
Functional programming supports distributed computing

* Many Functional Languages only support Single Argument Functions 
- Currying : Converting a function with n arguments in n functions with one argument

    // ADD with 2 parameters
    ADD := func(x, y int) int {
        return x + y
    }
 
    ADD(1,2) -> 3

	// Curried ADD
	ADDC := func(x int) func(int) int {
		return func(y int) int {
			return x + y
		}
	}
    ADDC(1)(2) -> 3

: Benannt nach Haskell Brooks Curry (1900-1982, USA)

* Functional Composition
Functions can be composed to new functions
    g(f(x)) -> (g ◦ f)(x)

    // Function f()
    f := func(x int) int {
        return x * x
    }

    // Function g()
    g := func(x int) int {
        return x + 1
    }

    // Functional Composition: (g◦f)(x)
    gf := func(x int) int {
        return g(f(x))
    }

    fmt.Printf("%v\n", gf(2)) // --> 5

: TODO LogToFile

* Exercise 5.2 - Functional Composition (g◦f)(x)
- Write a Go function to compose two unknown unary functions (one argument and one return value)
- The functions to compose should be arguments
- Write a Unit Test for that function

    // Type any makes the code readable
    type any interface{}
    type function func(any) any

    compose := ???

    square := func(x any) any { return x.(int) * x.(int) }

    fmt.Printf("%v\n", compose(square, square)(2)) // --> 4*4 = 16
    fmt.Printf("%v\n", compose(compose(square, square), square)(2)) // --> 256

* Functional Composition (2)
Functions can be composed with functions as parameters
    g(f(x)) -> (g ◦ f)(x) 

    // Type any makes the code readable
    type any interface{}
    type function func(any) any

    compose := func(g, f function) function {
        return func(x any) any {
    	    return g(f(x))
        }
    }

    square := func(x any) any { return x.(int) * x.(int) }

    fmt.Printf("%v\n", compose(square, square)(2)) // --> 4*4 = 16
    fmt.Printf("%v\n", compose(compose(square, square), square)(2)) // --> 256

* History: The Lambda Calculus
.image https://upload.wikimedia.org/wikipedia/en/thumb/4/4d/Knights_of_the_Lambda_Calculus.svg/316px-Knights_of_the_Lambda_Calculus.svg.png 200 200
- What is it?
- Why is it useful?
- Where did it came from?
.link https://www.youtube.com/watch?v=eis11j_iGMs Professor Graham Hutton explains the Lambda Calculus (Cool Stuff :-)

Hint: To understand this video you will watch it at least three times :-)

* Summary of the Introduction to Lambda Calculus
- Pure Functions have no internal state
- The Lambda Calculus is very different to the Turing Machine in this way
- The lambda calculus knows only three primitives: Variables (x,y,z), building functions λx.x, applying functions "(λx.x) 5" with values
- There are no datatypes (number, logical values) - values can be functions, no built-in recursion!
- It can encode any computation (Church-Turing thesis)
- Lambda Calculus is present in most major programming languages


* Lambda Calculus in Go: Combinators

    // This is the key: A Recursive function definition for all functions!!!
    type fnf func(fnf) fnf

.code ../src/functional/lambdacalculus/mockingbird/main.go /Combinators/,/COMB OMIT/
.play ../src/functional/lambdacalculus/mockingbird/main.go /TEST COMB START OMIT/,/TEST COMB END OMIT/

* Lambda Calculus in Go: Helper for printing
.code ../src/functional/lambdacalculus/mockingbird/main.go /NAMER START OMIT/,/NAMER END OMIT/

* Lambda Calculus in Go: Boolean Logic
.code ../src/functional/lambdacalculus/mockingbird/main.go /Boolean/,/BOOL OMIT/
.play ../src/functional/lambdacalculus/mockingbird/main.go /TEST BOOL START OMIT/,/TEST BOOL END OMIT/

* Lambda Calculus in Go: Helper (2)
.play ../src/functional/lambdacalculus/mockingbird/main.go /Debugging/,/DEBUG END OMIT/

* Functional Numbers
.code ../src/functional/lambdacalculus/successor/main.go /Functional Numbers 1/,/NUMBER END OMIT/

* Functional Numbers
.play ../src/functional/lambdacalculus/successor/main.go /Functional Numbers SUCCESSOR/,/EOF OMIT/

* Lambda Calculus in JavaScript
        TRUE = a => b => a;
        FALSE = a => b => b;
        NOT = f => a => b => f(b)(a);

        f = x => x + 10
        g = x => x + 20

        TRUE(f)(g)(3)       // -> 13
        FALSE(f)(g)(3)      // -> 23

        NOT(TRUE)(f)(g)(3)  // -> 23
        NOT(FALSE)(f)(g)(3) // -> 13

.link https://www.youtube.com/watch?v=3VQ382QG-y4 Fundamentals of Lambda Calculus & Functional Programming in JavaScript

* Famous Functional Languages inspired by the Lamda Calculus
- Haskell ([[https://www.youtube.com/watch?v=1jZ7j21g028][Introduction]])
- ML
- Clojure
- F#
- Scala
- JavaScript

* Haskell Demos

- fibonacci
- partial application (dot product)
- Monads

:import Data.Time.Clock
:import Control.Concurrent

:main = do {
:    x <- getCurrentTime;
:    print x;
:    threadDelay 1000000;
:    x <- getCurrentTime;
:    print x
:}




* Palindrome Problem in Functional (pure) Languages

- Haskell

    is_palindrome x = x == reverse x

- Clojure

    (defn palindrome? [x]
        (= x (clojure.string/reverse x)))

* Palindrome Problem in Functional (impure) Languages

- F#

    let isPalindrome (x: string) =
        let arr = x.ToCharArray()
        arr = Array.rev arr

- Scala

    def isPalindrome[A](l: List[A]):Boolean = {
        l == l.reverse
    }

- Go

    func IsPalindrome3(x string) bool {
        return x == strings.Reverse(x)
    }

* Functions as First Class Citizens in Go
- Go supports functions as 1st Class Citizens: Clojures und Lambdas
- Functions can be assigned to variables
- Functions can be used as function parameters and return values (High Order Functions)
- Functions can be created inside functions
- The Go standard library uses functional constructs

* Sample from the Go Standard Library
- strings.map

    // Map returns a copy of the string s with all its characters modified
    // according to the mapping function. If mapping returns a negative value, the character is
    // dropped from the string with no replacement.
    func Map(mapping func(rune) rune, s string) string

- Usage

    s := "Hello, world!"
    s = strings.Map(func(r rune) rune {
        return r + 1
    }, s)
    fmt.Println(s) // --> Ifmmp-!xpsme"

* Go does not have an API similar to Java Streams
- It is possible to build such an API in Go
.code ../src/functional/streams/streams_test.go /array/,/lambda/

* Exercise 5.3 - Map / Filter / Reduce

.link https://github.com/s-macke/concepts-of-programming-languages/blob/master/docs/exercises/Exercise5.md#exercise-53---map--filter--reduce Exercise 5.3
Map/Reduce is a famous functional construct implemented in many parallel and distributed collection frameworks like Hadoop, Apache Spark, Java Streams (not distributed but parallel), C# Linq

- Implement a custom M/R API with the following interface:

    type Stream interface {
        Map(m Mapper) Stream
        Filter(p Predicate) Stream
        Reduce(a Accumulator) Any
    }

- What is the type of Mapper, Predicate and Accumulator?
- How can you make the types generic, so they work for any type, not only for string?

* Generic Mapper, Predicate and Accumulator

.code ../src/functional/streams/streams.go /EXERCISE 5.3 START OMIT/,/EXERCISE 5.3 END OMIT/

* Exercise 5.4 - Word Count (WC)

Word Count is a famous algorithm for demonstrating the power of distributed collections and functional programming. Word Count counts how often a word (string) occurs in a collection. It is easy to address that problem with shared state (a map), but this solution does not scale well. The question here is how to use a pure functional algorithm to enable parallel and distributed execution.

After running Word Count, you should get the following result:

    INPUT:  []Any{"a", "a", "b", "b", "D", "a"}
    OUTPUT: "a:3, b:2, D:1, "

Questions

- How can you implement the problem with the already built Map()/Filter()/Reduce() functions?
- Write an Unit Test to prove that your solution works as expected!

* Classic Word Count Sample
.code ../src/functional/streams/streams_test.go /wordcount/,/ENDWC OMIT/

* Questions
- How can you implement parallel execution for our API?
- How can you implement distributed execution for our API?

* Summary
- You can do functional programming with Go
- Generics and type inference for functions are missing, but will be implemented in Go 1.18
- Type definitions for functions make code readable
- You can use functional patterns and generic programming with extra casting (type assertions) 
- Functional patterns like Map/Filter/Reduce are easy to implement in Go
- Reflection can help to avoid casting, but it is slow!
